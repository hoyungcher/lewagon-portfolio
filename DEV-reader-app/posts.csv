"mskog/visual-studio-code-plugins-for-ruby-2096","Visual Studio Code plugins for Ruby and Rails","A quick list of all the plugins I use for Ruby on Rails development.

You will need this for syntax support and such so this is a must have.

This one is a must have. It will enable ""Go to definition"" in Ruby for all classes, modules and methods. It also has context-aware code completion and documentation. Extremely handy. If you only choose one of the plugins on this list(except for the Ruby one) then make it this one. It is quite something!

If you use Rubocop then this extension will let your format your code using Rubocop. This is highly recommended as it will enforce a consistent style in your code. Especially if you are working in a team.

Pro tip: If you use Spring then you can use spring-commands-rubocop to make a binstub for Rubocop and then it will run much faster. You will need to set the ""ruby.rubocop.executePath"" setting in VSCode to ""bin/"" for this to work properly.

If you are using the default Rails way of organizing directories and such then this plugin can make navigating your application a breeze. You can use it to quickly navigate between controller actions, model, views and even specs.

This will enable the use of ""Go to definition"" in VSCode for view partials. Very handy for quickly navigating through a complex view structure.

This is a simple extension that will open the latest migration in your application. I use it all the time so it is absolutely worth having.

If you use RSpec then this is a handy extension. It will make it very easy to add focus: true to your specs to run only that spec.

Quickly toggle ERB tags in your views. Will save you quite a bit of typing.

Syntax support for Haml.

This uses the haml-lint gem to help you make your Haml code clean and consistent.

Add end automatically to methods and statements.

If you use the Dash documentation browser for Mac then you can use this extension to quickly jump to the documentation for any class or method.

Quickly jump to the open file on Github.

This will copy the relative path of any file as defined by the project root. Great for doing things like running a specific spec and such.

Will add intellisense for any CSS class in your project, even those defined in external style sheets like Bootstrap.

No-nonsense formatter for HTML, CSS, Javascript and more. It is opinionated and does not allow for much configuration. It is perfect if you want something simple and don't want to fiddle with configuration files.

Another formatter. This one is a ""meta formatter"" that uses other formatters. You can thus use Prettier for CSS and something else for HTML, all managed by Unibeautify. This is also the only formatter that I know of that does a decent job of handling ERB templates. Use the Pretty diff formatter for ERB templates and you will have a pretty good time.

Vim
This will essentially turn VSCode into VIM for editing. I gave this a shot and didn't look back. It might take you a couple of weeks to get proficient with it but after that you'll be golden. This is in my opinion an excellent plugin and it will make you a lot more efficient. Check out this article for a very good introduction to this plugin.

There you go! Those are all my plugins for Ruby on Rails development. Did I miss one? Let me know on Twitter!","Magnus Skog","false"
"molly_struve/level-up-your-ruby-skillz-working-with-arrays-hnn","Level Up Your Ruby Skillz: Working With Arrays","When I first started out, there was a senior engineer that I worked with who was a wizard when it came to working with arrays. He taught me all the best tricks to writing succinct and clean code when it came to dealing with arrays. Here are the methods that I find the most useful and I think are good to have in your Ruby toolbox right from the start.

If you want to jump straight to the code without the explanations checkout the cheatsheet at the bottom!



Before we dive into some of the fancier methods above, we first need to start with the most basic, each. each will call a block once for every given element in an array. When it is done, it will return the original array. That last part is key and is easy to forget. Even those of us who have been working with Ruby for a while sometimes forget it. Here is an example.

That code will produce the following result when run in a console. NOTE: In the example below and those that follow, irb simply means I am in a Ruby console.

For each number in our array we printed ""hi"" plus that number. Then, after we have finished traversing the entire array, our original array is returned.

Keep in mind, I am using the do/end block notation above, but you can also use the bracket syntax for your block which is shown below.

As you can see, regardless of syntax, the result is the same. I am going to continue to use the do/end syntax throughout this guide because I think it makes the code and logic easier to understand. With that said, all of these methods will work with the bracket syntax as well.



In the early days, when I was new to Ruby, every time I wanted to build an array I did something like this:

I quickly learned there was a better way, and that is by using map. map returns a new array with the results of executing the block once for every element in your original array. Here is an example:

We add 2 to every number in our original array and then group those results up into a new array, which is returned. Now our code is a bit cleaner and more compact.



map is great for collecting a set of results, but what happens when you want to map over nested arrays? That is when flat_map comes in handy. If you find yourself with a set of nested arrays then you might want to checkout flat_map. For example, say you have code like this with a couple of nested arrays.

We get a single level array, which is what we wanted, but how could we tighten this up? Let's try using map.

Hmmm, that is not quite what we want. We want a flat, single level array and map is creating a nested one. In order to flatten that nested array we can use flat_map.

flat_map works similar to map in that it collects the results from your block into an array, but as a bonus, it will flatten it. Under the hood, flat_map is concatenating all of the inner arrays into a single one. Using flat_map returns that single level array we wanted.



Similar to the map example, when I was starting out, if I wanted to conditionally select elements from an array, for example, choose all the even numbers, I would do something like this:

It works, but there is an even more succinct way, and that is by using select. select returns an array containing all elements for which the given block returns a true value. This means we can rewrite our above block of code like this!



Now we are going to kick it up a notch. What if instead of wanting all the even numbers back from an array, you only want the first even number that you find? For that you can use detect. detect will return the first entry for which your block evaluates to true. So if we run a similar block of code as above, but replace select with detect, you can see we get back only the first even number.

One important thing to note here is that we are now returning a number(our entry) and NOT an array.

But what happens if our block never evaluates to true? What if there are no even numbers in our array? In that case, detect will return nil.

To summarize, detect will return the first entry your block evaluates to true for OR it will return nil if no entry evaluates to true for your block.



Now let's look at the inverse of select, which is reject. reject will return all entries for which your block evaluates FALSE. So instead of doing this:

We can simplify the above code and do something like this instead:

This time we will return each number which is not even, so those where number.even? returns false.



We have just seen two ways we can filter through arrays in Ruby using select and reject. But what if you want to straight up separate your single array into two arrays, one for even numbers and one for odd numbers? One way to accomplish this is by doing:

But, there is an even better way, you can use partition! Hold on to your seats for this one. partition will return TWO arrays, the first containing the elements of the original array for which the block evaluated true and the second containing the rest. This means we can take what we wrote above and simplify it to:

As you can see, partition will return two arrays, one with even numbers, and one for odd numbers. If we want to assign our even and odd variables all we have to do is

However, as you can probably guess, there is an even better way! We can eliminate that single result variable altogether and write something like this

This syntax is going to automatically assign the first array to even and the second array to odd. You can use this array assignment syntax anytime you are dealing with nested arrays. Here is an example of how you can breakup 3 arrays.



count for the most part is pretty self explanatory, by default, it will count the number of elements in your array.

But, did you know it can do so much more? For starters, can pass count an argument. If you pass count an argument, it will count the number of times that argument occurs in your array.

You can also pass count a block!😲When passed a block, count will return the count for the number of entries that block evaluates to true for.

Every number that is odd in our array was counted and the result returned was 4.



Last but not least, I want to talk about traversing an array with an index. Often when we want to keep track of where we are in an array of elements we will do something like this.

However, there is a better way! You can use with_index with each, or any of the methods I listed above, to help you keep track of where you are in an array. Here are some examples of how you can use it. (REMEMBER: Array indexes start at 0 😃)

In this example we are simply iterating over our array and printing out the index for each element.

In this example, we are combining the index with the letter in our array to form a new array using the map method.

This example is a little trickier. Here we are using our index to help us select the element in our array that is at index equal to 2. In this case, that element is ""c"".



The last tidbit of knowledge I want to leave you with is that any of the methods above that return an array(all except count and detect), you can chain together. For these examples I am going to use bracket notation because I think it's easier to read chaining methods from left to right rather than up and down.

For example, you can do this:

Let's break down what is happening here given what we learned above.
1) map is going to add 2 to each of our array elements and return [3, 4, 5, 6]
2) select will select only the even numbers from that array and return [4, 6]
3) reject will remove any number equal to 6 which leaves us with [4]
4) Our final map will prepend ""hi"" to that 4 and return [""hi 4""]


Congrats, you made it all the way to the end! Hopefully, you find these array methods useful as you are writing your Ruby code. If anything is unclear, PLEASE let me know in the comments. This is my first time writing a tutorial so I welcome any and all feedback 🤗


If you would like all of these code examples without the lengthy explanations checkout this cheatsheet that @lukewduncan
 graciously put together!","Molly Struve","false"
"molly_struve/level-up-your-ruby-skillz-working-with-hashes-4bid","Level Up Your Ruby Skillz: Working With Hashes","Last week I tackled Ruby arrays and shared some of the methods I find the most useful for working with them. This week I want to talk about HASHES! Before I dive head first into my favorite methods, I want to give a quick summary of what a hash is in Ruby and how it works. The definition of a Hash straight from the docs themselves:

A Hash is a dictionary-like collection(If you are a Java person, think maps) of unique keys and their values. Also called associative arrays(honestly, I have never heard this before but 🤷), they are similar to Arrays, but where an Array uses integers as its index, a Hash allows you to use any object type.

One of the keys(pun intended 😉) in that definition is that a Hash allows you to use any object type as your index. Most people when they think of a Hash think of this.

But hashes can be so much more in Ruby! For example, all of these are Hashes.

Any object type your heart desires can be a Hash key. Now that we have the semantics and the definition down, let's get to the methods!

NOTE: Just like in the array tutorial, if you see irb in the code snippets that means I am working in a Ruby console. Also, I made a code CHEAT SHEET if you want the code without all the explanations.



One of the most valuable things you can do with a hash is iterate over it. One of the easiest ways to loop over a hash is to use each. I don't know about you, but when I started out using Ruby, my hash each statements looked like this.

Here, I am executing my each method the same way I did for my arrays. The difference now is that pair is an array itself. The first element is my key and the second element is my value. NOTE: After executing the block for each of our key/value pairs, the original hash that we iterated over is returned.

The above way works, but there is an even slicker way, you can separate that pair by passing two arguments to your block. This means you can rewrite the above like this:

Now we have two separate variables, one representing the key and one representing the value.



But what if we don't want all the keys and values? What if we just want the keys or just want the values? There are methods for each of those!

Notice, that once again, regardless if we use each_key or each_value, we still get the original hash back after we are done iterating over it.



Let's say you just want an array of the keys or you just want an array of the values from a hash. To do this, you can use keys or values. Both will return an array of the keys or values for a given hash.



Another couple of pretty straight forward methods are the key and value predicates. If you want to know if a key or a value exists in a Hash then you can use key? or value?.

This is pretty straightforward, but there are a couple of nuances I want to point out. For starters, when you are looking for a key, you have to make sure you are looking for the proper datatype. For example, if you have a hash with symbol keys, searching for a string will return false.

Make sure the datatype you are searching for matches the datatype of your keys or values.



Now we know how we can check if we have a specific key or value, but what if we want to actually look up the value for a key? Well, there is always the standard way to do it and this is what I learned first.

Simple and easy. If the key is there, we return its value. If the key is not there we return nil. But what if we have some more complicated logic? For example, what if we want to return the key's value OR, if the key does not exist, we want to return some default, like 0? With what we know so far we could do this

It works, but it is a pretty decent chunk of code to get it done. Instead, we can replace that large chunk of code with one simple method, fetch. fetch has a lot of options and behaviors so lets unpack each, one at a time.

1) fetch with NO arguments will return the value if it is present. If the value is not present, fetch will raise an error. This is great if you want to raise an error when a key cannot be found.

2) fetch WITH arguments will return the value if it is present, just like before. Here is where it gets slick and can help us out with our original use case, if you pass fetch an argument and the key is not present, it will return the argument! 🔥



fetch works great when you have a single level hash and want to return a value from it using a key. But what if you have several nested hashes? For example

Normally to get the value of c you would want to do

which would traverse your nested hashes and return your value. But what if you are not sure whether all those levels are present? For example, let's say you are working with an API to get user data. Sometimes you find the user you are looking for and get this back.

Other times, you don't find the user you want and you get this back,

In this case, we can't just assume we have the user information, because if we don't have the user information, we will end up raising an error.

To avoid this, we could do

This ensures if we have the user data, we return the first name. If we don't have the data, then we return nil. Turns out, we can avoid ALL of this by using dig. dig extracts the nested value specified by a sequence of key objects. However, if any one of those nested keys do not exist, it will return nil. 🎉

dig is great when you want to traverse a hash but are not sure what its structure might be. It allows you to work with a hash without worrying about handling a bunch of errors or doing a bunch of present? checks using if/else blocks.



Now we are going to kick it up a notch. What if we have a hash where all the keys are symbols, but we want to change them all to strings? In the early days we would do this.

It works, but you guessed it, now there is a better way. That better way is transform_keys. transform_keys allows you to iterate over a hash and will return a new hash. The new hash keys will be the result from executing the block for each of the original keys.

IMPORTANT transform_keys(above) and transform_values(below) are only available in Ruby 2.5 and above. If you get the following error, then you are likely working with a version of Ruby below 2.5 NoMethodError: undefined methodtransform_keysfor {:a=>1, :b=>2, :c=>3}:Hash



transform_values works the exact same way as transform_keys, except it allows you to update the values. When it is done executing your block, it will return a new hash with the new set of values.



Now we are going to get into some familiar territory if you read my first array tutorial. Just like for arrays, you can use select for hashes! select for a hash works basically the same as an array, it returns a new hash with the key/value pairs that your block evaluated true for.



Let's say you have a hash and you just want back a specific set of keys and their values. You could do something like this

But Ruby has a simpler way and that is by using slice. slice will return a hash with only the keys you request via your arguments. What we have above can be simplified to



Back we go again to familiar array territory. reject for a hash works the same way it does for an array. reject will return a new hash consisting of all the key/value pairs for which your block returns false.



Last, but not least, we need to cover chaining. Any of the methods above that return a hash, you can chain together. For these examples I am going to use bracket notation because I think it's easier to read chaining methods from left to right, rather than up and down.

Here is an example of chaining some of the above methods together.

Let's break down what is happening here given what we learned above.
1) transform_keys changes each of the hash's keys to a string and returns { ""a"" => 1, ""b"" => 2, ""c"" => 3 , ""d"" => 4}
2) slice will select only keys ""a"" and ""b"" and their values and return { ""a"" => 1, ""b"" => 2 }
3) reject will remove any key/value pair where the value is equal to 2, that leaves us with { ""a"" => 1 }
4) Our final transform_values will change our hash's values into a string with ""hi"" and our number following it. The final result is {""a""=>""hi 1""}


You made it to the end!!! Hopefully you are feeling a little more comfortable with Ruby hashes now and have a couple more methods in your toolbox that you can use. If you have any questions or anything needs clarification please don't hesitate to drop a question in the comments!

If you want a quick reference for these methods I made a handy cheat sheet with just the code from each example.  ","Molly Struve","true"
"https://dev.to/lampewebdev/going-down-the-youtube-tech-guru-hole-or-how-you-can-spot-scam-artists-208e","🤑🥳😎Going down the youtube tech guru hole or how you can spot scam artists","I find it fascinating what you can find on youtube these days.

People are selling you shortcuts to your dreams and a secret that only they know!

You know the guy in front of an expensive car that was a multi-millionaire in his 20ths and now wants to help you to become also a multi-millionaire!

It is so easy that everybody can do it! Yes, you and you can do it! Even a baby could do it!

You just need to give him or her 3000 or 10000 or 300 Zelda rupees!

It is that easy! You will make that money back in no time!

Sarcasm over

Let's go over some tactics used by these kinds of scam artists and how you can spot them.




  Promises to good to be true


One thing we have to understand those scam artists, in general, are good storytellers. I mean excellent storytellers. Keep this in mind for the rest of this post.

This is how most of there ""sell pitches"" because this is what they are, will start.

The first thing they will do they will target the right audience. They do that on YouTube, Facebook, and Instagram. So you will see a short ad before the actual coding video you wanted to watch.

That video has a formula.
1) A hook. This hook can be something like


""So, you want to be a javascript freelancer?""
""Don't push skip because ...""
""Don't you want to be ...?  here is how.""
 etc. etc. etc...


You can see a pattern. This is on purpose and designed to make you think that if you skip, you will not hear some crucial and life-changing information.

It is a psychology trick. It is the same trick as with endless scrolling on Facebook or Instagram. ""Maybe when I just scroll long enough, I will find something that I really need"". We all know we will just end up in some viral videos that don't make any sense, or you will watch some cats.

Okay, now that you are listing to them. We come into phase two.

2) Getting to know each other


""Hey, I'm ... I'm a freelance developer making 1 Million when I was 21 years old.""
""Hey, I'm ... I'm an ex-googler, ex-facebook, and ex-Netflix employe.""
""Hey, I'm ... <Insert something that is either too good to be true or something that looks amazing but isn't""


The intent of this is to do at least two things to you. The first one is to establish a connection with you. We as humans trust people more the more we know the other person. This is why influencer marketing works better than dull old commercials because, in your brain, a friend is selling something to you and not a strange guy from the TV.

The second one is to show you what that scam artist has achieved and why you should listen to him/her. ""1 Million when I was 21 years"". Would you ever introduce yourself to strangers on the streets like that? ""Hey, I'm Warren Buffett, and I'm the richest man on earth."" Please say that you would not do that.

So now you want to become like that person, right? I mean, who does not want to be 21 and have 1 Million Zelda rupees?

If someone is telling you, ""Hey, I worked at a big company, look at me!"" what does it mean? You have to question that. That person could be anything at that company, and just because you worked at a big company does not mean that you are good at what you are doing. I know brilliant people that work at small startups. This sentence is just there to make their next claims heavier so they can hit you harder!

Keep in mind you don't know that person. You only know a produced and scripted video of that person. So yeah, don't forget to question everything, and yes, question this blog post!

3) Showing some random charts/numbers
Now that you and the scam artist know each other, it is time to show you some numbers!

This is where they will either show you some whiteboard and draw random numbers on it, or they will show you some charts. Even if they show you a screenshot of some online bank interface, should you blindly believe in that? I think by now, you know the answer.

If it is a website, it is super easy to change such numbers on a website without even using photoshop. Just open the dev tools and find the right HTML element and just change it! Here I have 100, 000 000 followers, on dev.to!



All of these numbers are fake! But don't they look great? This took me 2 minutes!

So yeah, to keep this short. Don't trust any chart you haven't faked yourself!

But why is this added? To make you want to see how that guy or girl made it! It is just there to hook you even more in! Like people are making 120k at google pfff, this guy is making a million!

They are catering to your desires, and this works best on people how are already in a bad situation in their lives. So be very careful with random numbers that people are showing to you!

4) Buzzwords overkill!

Now the ""how"" parts will start. Since the goal is to sell you 'education'.

This sentence is a real sentence from a video that is selling some online course:
""Listen up; you will be learning the basics of javascript, you gone be learning advanced object-oriented programming, you be learning DOM, GitHub, Visual Studio Code, Command Line, Version Control, AJAX, JSON, API, ES6 and more...""

It is like firing a machine gun with buzzwords. Of course, you can just say: You will be learning the minimum basics of frontend web development. Does this sound that good? No. Besides, the part of having javascript in advanced object-oriented programming in one sentence does not make any sense. You will probably know most of these buzzwords from somewhere.

Again this comes down to make you feel familiar with that scam artist. ""Oh, he/she is using and teaching the same things I want to learn"".

Yes, because you can not do anything on the frontend without javascript and all the rest. Like Visual Studio Code that is just right the most popular code editor. I mean, you need a code editor to write code. Having GitHub and Version Control in the same sentence is kind of redundant because GitHub's main feature is to be an interface for Version Control tolls. Yeah, I know you can do more with it now, but still, it is kind of pointless to name both of them.

Why is ""DOM"" on that list? I have no clue. Even if you learn ReactJS or VueJS or angular, it still comes down to the DOM. 🤷‍♀️

Let's get back to the topic.

4) The course information

So now usually you will get a very little info about what is actually in that course. Just to have a real example again. In the Video with the buzzwords, you would get 15 modules with 30+ hours of video content. This means around 2 hours of content for each module.

I mean 30+, and you will be a profitable developer? This must be the best teacher in the world! From knowing nothing about development to becoming a millionaire in 30+ hours.

Sorry but that is not reasonable for 99% of people. You will probably learn something, but you will only learn things that are already for free on the internet. You will get more like an introduction to web development.

Also, this part is usually the shortest because if they would stay too long on that part, you would also see the flaws of it!

5) ""We have proof that it works.""

Fake testimonials! Now the scam artist will show you some random guy/girl that made it with there course! Don't believe in a single one of them!

Why? It is so easy to get fake testimonials even if it is a video!
You can buy them for 5 dollars at fiverr.com. Or just go to the 'Spokespersons Videos' section. Or just google ""buy testimonials"". This is another rabbit hole I would love to dig into.

I mean, you don't even need to buy a fake testimonial. Just ask someone that is right now taking that course how he/she likes it and boom. Fake testimonial for free! Or just ask a random friend. 🤷‍♀️

Also, one thing you have to keep in mind: Even if they a real, these people don't get these jobs or money just because of one online course. Usually, they already have some experience or have a University degree in something similar to computer science.

Also, keep in mind they are usually showing between 1 and 3 people, and yeah, you can say its because of the length of the video they don't want to show more. If they have like 10 000 people taking there courses, then three people are not very significant? If you take 10 000 random people, then yeah, some of them will have more success then others. It is nothing special, and just how the world works.

What they could do is now show a chart with statistics, right? Yes! But you will never see that because it would look bad. Then again, they could also fake that.

6) Money-back guarantee!

You can get your money back until the last second of the online course! Yes, even at the last minute! Just with 1 sec to go! This sounds amazing, right?

No, and here is why: You not even finished the course and probably did not make any money and you don't know if you will earn any money, but what was the promise to you? That you will be rich in X months, right?

So why do I not have that guarantee for X months after the course ends? Or why not pay after you made X amount of money?

I have seen both possibilities on some other online courses!

I mean, it is straightforward why: because the claims they make will not be reached by 99% of the people attending in the time they promise you would!

7) The sell

Now that you have listened to pumping music and all these ""benefits"" you should feel hyped and highly motivated to make that money!

Now they will ask you if they can be your mentor, and you need to be quick because the registration is limited in some way either by time or by places or by both.

The scam artist will say how much his life has changed and how much your life will change after that course.

So yeah, have you ever seen a youtube video that will go offline after X hours, and if that video reaches 500 views, it will delete itself?

Usually, what you want is the opposite, right? You want the video to stay as long online as it can and to have millions of viewers?

Have you ever seen a ""Limited Edition"" of something? Like a limited edition of a bottle of coke? Is inside still the same coke as before?

""Supreme"" is entirely based on that strategy. They will produce X amount of clothes and then never again.

Here it is the same. It is called ""Scarcity marketing"". If you want to know more about that, just google it. You will find plenty of examples.

The end of the video!

Now you either saying: okay that was rediculous
or you will buy it!




  outro


Just to make some points clear:


Not all online courses are bad
You should inform yourself before taking them
Usually, you can get all the necessary content for free. One of those websites is freecodecamp.org

I don't want to name any of these tech YouTubers by name. I want you to see the general scam.


I hope you liked that post! If you want a follow up, please comment, like and share. So I can know that you are interested in content like that!

👋Say Hello! Instagram | Twitter | LinkedIn | Medium | Twitch | YouTube","Michael ""lampe"" Lazarski","false"
"https://dev.to/madebycrevans/5-approaches-that-helped-me-launch-an-mvp-in-a-weekend-djf","5 approaches that helped me launch an MVP in a weekend","Last year I launched Lancerlist, an online platform that allows freelancers to promote themselves in their city and companies to find local freelancers.

I wrote an article about how I designed, built and launched the MVP (Minimum Viable Product) over a weekend, and this proved popular with designers, developers, and makers alike.

I thought I’d write a follow up piece about 5 higher-level concepts or approaches I practiced during the development process that helped me achieve the goal of launching the MVP over a weekend. Let’s get into it.


  
  
  Define what success looks like


Before laying a single-pixel or writing a single line of code, I defined what success would look like in a minimum viable product trying to solve my problem. The problem, in this case, was ‘making local freelancers discoverable’.

I defined that success trying to solve that problem, would be freelancers seeing the value of the platform and sign up through their own free will. It would validate or invalidate the problem in the eyes of freelancers and prove the demand for a solution.

This influenced I approached the design phase, specifically, the landing page displayed all the cities current freelancers were from, thus providing a sense of social proof. It also influenced the sign up and onboarding flow, I wanted to make the act of signing up as frictionless as possible.

With such a specific focus I could cut out ideas I had because they did not help me achieve that goal, this ended up saving design and development time normally associated with bloated product scope.

The results of this were clear, 13% of unique visitors that hit the homepage ended up signing up and 92% of freelancers that signed up, completed their profile.


  
  
  Keep it simple


Furthering from the first point, cutting out unnecessary features was a key factor in being able to design, build and launch the MVP over a weekend. When you start a new project, it is common to a million ideas and features that all sound great, this project was no different.

The method I use to cut out all non-essential features is to create a graph, on the Y axis, impact of feature and on the X axis, time to build. I then plotted all my ideas on the graph, from this I had a visual representation of my ideas and could discern which would have the most impact for time spent.



This method combined with my first concept, helps narrow the scope of the project down to a core feature or user flow. The benefits are similar, less time spent on designing and developing features that don’t impact the success of the project. Having a narrow scope also helps with writing copy and producing marketing materials as you an explicitly define the value your target users with receive.

For Lancerlist, the core feature I chose was the freelancer discovery flow. This would be the value proposition presented to users, providing the most impact on our defined success while being achievable in the time.

The effect of this was a simple discovery flow that allowed freelancers to be found through their city and then through their skillset. I could have made a more complex search algorithm but that would increase development time and not have a major impact on the success.

I then used the time/impact graph to create the projects roadmap, building more features in the months after launch.


  
  
  Don’t reinvent the wheel


The development phase for Lancerlist took approximately 11 hours all in. How was this possible? I didn’t reinvent the god damn wheel.

By using the technology you know, you can apply the knowledge you’ve spent years learning directly towards building your solution, you’re not spending time learning the intricacies of a new language and the complications of deploying it.

Whether you’re building the project in PHP or Next.JS, you are trying to validate an idea, solve a problem, that is the purpose of an MVP. It can be tempting to use the latest fancy pants JavaScript framework but that won’t impact your success, there’s a time and place for that learning.

For Lancerlist, my technology stack was mainly based on Laravel, I’ve used it for years, I know the ins and outs of it. By using what I already have experience with, I could reuse code from other projects, this saved me a huge chunk of time that would elsewise be used following tutorials and fighting bugs.

I also used packages to speed up development, if something’s been done before, there’s likely a package that can help you. These packages are likely well tested, handle edge cases and are well documented, all help save you time and get you closer to the outcome you desire.

I don’t care what you use, code, no-code, it doesn’t matter, just don’t reinvent the wheel.


  
  
  Reusable code


Another approach I took to the development was to consciously write code in a reusable way. In practice, this means creating a simple design system and componentising elements.

With Lancerlist, I created an extremely simple design system, I made a CSS variables file that had all the projects colours, spacing, type-scales, and grid systems defined. I could then use these variables throughout the application. This has multiple effects. It speeds up development as I don’t need to remember 10 different hex codes each time, I can just remember the variable name (e.g. $color-primary). It also improves the quality and consistency across the product, a heading on one page is the same size as a heading on another page. Simple stuff but worth mentioning.

I also componentised some of the common elements across the project, for example, buttons. By creating button components, the look, feel and functionality of a button is consistent across the whole product, providing a better user experience. This also speeds up development, every time I want a button, I can now just import the button, provide some parameters and we’re good to go instead of building from scratch each time. Another plus for components is if I choose to change the button design in the future, I only have to modify it once and it will be applied throughout the product.

By making a conscious effort to make common elements reusable, you can improve development speed, code quality, and user experience. Also, your future self with love you!


  
  
  Repurpose tools you know


The last concept I used is similar to “don’t reinvent the wheel”, repurpose the tools you know, even if it’s for things they’re not designed for.

Any tool that takes less time to setup than it takes you to design and build is worth implementing. Need to send welcome emails? Setup a Zapier integration that watches for new users in your database and sends and email when it detects one. Need to do customer support? Hook up slack to handle requests in an interface you already know and love.

For Lancerlist, I added a list of the 1,000 most populous cities but I knew this wouldn’t cover everybody, instead of custom building a custom city selection feature I just added a button saying “City not here? Request it”, this opened up a Twitter intent, with the copy pre-written and a blank space where they could add the city. Was it elegant? Not really. Did it work? Absolutely! 100’s of people requested cities through this system.

It may not scale, it doesn’t need to, you can build a custom solution later once your idea has been validated and/or the tool becomes unmanageable.


  
  
  Final thoughts


So, there we have it, these were a few of the approaches I used that helped me design, build and launch Lancerlist’s minimum viable product over a weekend. I hope some of these concepts can help you while you’re building your next product.

Agree or disagree with anything you’ve heard here? You can find me at @MadeByCrevans on Twitter.

This article was originally published on my blog at madebycrevans.com.

Lancerlist today has over 1,000 freelancers registered and thousands of people using the platform each month. If you’re curious, you can view it live at Lancerlist.co.","Chris Evans","false"
"https://dev.to/helenanders26/what-do-you-find-difficult-about-sql-and-databases-o31","What Do You Find Difficult about SQL and Databases?","","Helen Anderson","false"
